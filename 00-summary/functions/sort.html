<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>基于BOOTSTRAP的HTML模板</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <link rel="stylesheet" href="../../bootstrap-3.3.6/dist/css/bootstrap.css"/>
    <!--[if lt IE 9]>
    <script src="../../bootstrap-3.3.6/dist/js/html5shiv.min.js"></script>
    <script src="../../bootstrap-3.3.6/dist/js/respond.min.js"></script>
    <![endif]-->
</head>
<body>
    <h1>首先实现几种排序，然后探究sort的实现机制</h1>
<ul>
    <li>实现了快速排序 quickSort</li>
    <li>带分区的快速排序未实现 quickSortWithPartition</li>
</ul>
<p><a href="../index.html">返回首页</a></p>
<p>本文抄袭自 <a href="http://www.codesec.net/view/164723.html">周骅</a></p>
<p>在javascript中，数组对象有一个有趣的方法 sort ，它接收一个类型为函数的参数作为排序的依据。这意味着开发者只需要关注如何比较两个值的大小，而不用管“排序”这件事内部是如何实现的。不过了解一下sort的内部实现也不是一件坏事，何不深入了解一下呢？</p>
<p>算法课上，我们会接触很多种排序算法，什么冒泡排序、选择排序、快速排序、堆排序等等。那么javascript的 sort 方法采用哪种排序算法呢？要搞清楚这个问题，呃，直接看v8源代码好了。v8中对 Array . sort 的实现是采用javascript完成的，粗看下来，使用了快速排序算法，但明显比我们熟悉的快速排序要复杂。那么到底复杂在什么地方？为什么要搞这么复杂？这是我们今天要探讨的问题。</p>
<p>快速排序算法
    快速排序算法之所以被称为快速排序算法，是因为它能达到最佳和平均时间复杂度均为O( n· log n )，是一种应用非常广泛的排序算法。它的原理并不复杂，先找出一个基准元素（pivot，任意元素均可），然后让所有元素跟基准元素比较，比基准元素小的，放到一个集合中，其他的放到另一个集合中；再对这两个集合执行快速排序，最终得到完全排序好的序列。</p>
<p>所以快速排序的核心是不断把原数组做切割，切割成小数组后再对小数组进行相同的处理，这是一种典型的分治的算法设计思路。实现一个简单的快速排序算法并不困难。我们不妨试一下：</p>
<script src="../../common/jquery-1.12.4.js"></script>
<script src="../../bootstrap-3.3.6/dist/js/bootstrap.js"></script>
<script>

    var arr = ["","","","","","","","","","","","fbx_upload_file_201610212104022431321.FBX","","","fbx_upload_file_201610212104305280309.FBX","","","fbx_upload_file_201610212104226384885.FBX","","","fbx_upload_file_201610212103536413357.FBX","","","fbx_upload_file_201610212105177246901.FBX","","","fbx_upload_file_201610212104526130828.FBX","","","fbx_upload_file_201610212103306076476.FBX","","","fbx_upload_file_201610212055106098842.FBX","","","fbx_upload_file_201610212055546878241.FBX","","","fbx_upload_file_201610212056065527324.FBX","","","fbx_upload_file_201610212056322340381.FBX","","","fbx_upload_file_201610212104401203175.FBX","","","fbx_upload_file_201610212103427641270.FBX","","","fbx_upload_file_201610212105049157348.FBX","","","fbx_upload_file_201610212104131785293.FBX","","","fbx_upload_file_201610212101268409439.FBX","","","fbx_upload_file_201610212103164509835.FBX",""]
    var nums = [ 3,9,5,10 ];
    var quickSort = function( arr, func ){
        if( !arr || arr.length === 0 ){ return [] }
        if( arr.length === 1 ){ return arr }
        var pivot = arr[ 0 ],
            small_set = [],
            big_set = [];
        for( var i = 1; i < arr.length; i++){
            if( func( arr[i], pivot ) < 0 ){
                small_set.push( arr[i] );
            }else{
                big_set.push( arr[i] );
            }
        }
        return quickSort( small_set, func ).concat(pivot).concat( quickSort( big_set, func ) );
    };

//    console.log(quickSort( nums, function( a, b ){ return b - a; }));
    function swap( arr, from, to){ if(from === to) return ; arr[from] += arr[to]; arr[to] = arr[from] - arr[to]; arr[from] -= arr[to]; }
    function quickSortWithPartition(arr, func, from, to){
        if( !arr || !arr.length ){ return []; }
        if( arr.length === 1 ){ return arr; }
//        debugger;
        from = from || 0;
        to = to || arr.length - 1;
        var pivot = arr[from];
        var smallIndex = from,
            bigIndex = from + 1;
        for( ; bigIndex <= to; bigIndex++ ){
            if( func(arr[bigIndex], pivot) < 0 ){
                smallIndex++;
                swap(arr, smallIndex, bigIndex);
            }
        }
        swap(arr, smallIndex, from);
        quickSortWithPartition( arr, func, from, smallIndex - 1 );
        quickSortWithPartition( arr, func, smallIndex + 1, to );
        return arr;
    }
    quickSortWithPartition( nums, function(a, b){ return a - b; } );
    console.log( nums );
</script>
</body>
</html>